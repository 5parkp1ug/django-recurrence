"""
Wrapper around the ``dateutil.rrule`` module.

Provides more consistent behavior with the rfc2445 specification,
notably differing from `dateutil.rrule`` in the handling of the
`dtstart` parameter. Additionally, the `byweekday` parameter in
`dateutil.rrule` is `byday` in this package to reflect the
specification. See the `Rule` and `Recurrence` class documentation for
details on the difference.
"""

import re
import datetime
import calendar

import pytz
import dateutil
from dateutil.rrule import (
    weekday,
    MO, TU, WE, TH, FR, SA, SU,
    YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY, SECONDLY,
)
from django.conf import settings


localtz = pytz.timezone(settings.TIME_ZONE)


class Rule(object):
    """
    A recurrence rule.

    `Rule` is a representation of a rfc2445 `RECUR` type, used in
    the `RRULE` and `EXRULE` properties. More information about the
    `RECUR` type specification can be found in the rfc at
    http://www.ietf.org/rfc/rfc2445.txt.

    An `Rrule` wraps the `dateutil.rrule.rrule` class while adhering
    to the rfc2445 spec. Notably a `dtstart` parameter cannot be
    specified with a `Rule` unlike `dateutil.rrule.rrule` as only one
    `dtstart` can be used with a set of `RRULE` and `EXRULE` rfc2445
    properties, therefore the `Recurrence` class (which is based on
    `dateutil.rrule.rruleset`) accepts a `dtstart` parameter instead.

    Documentation is largely sourced from the `dateutil.rrule.rrule`
    documentation at http://labix.org/python-dateutil

    :Variables:
        `freq` : int
            One of the enumerated constants `YEARLY`, `MONTHLY`,
            `WEEKLY`, `DAILY`, `HOURLY`, `MINUTELY`, or `SECONDLY`,
            specifying the base recurring frequency.

        `interval` : int
            The interval between each freq iteration. For example,
            when using YEARLY, an interval of 2 means once every two
            years, but with HOURLY, it means once every two hours. The
            default interval is 1.

        `wkst` : int
            The week start day. Must be one of the `MO`, `TU`, `WE`,
            `TH`, `FR`, `SA`, `SU` constants, or an integer,
            specifying the first day of the week. This will affect
            recurrences based on weekly periods. The default week
            start is got from `calendar.firstweekday()`, and may be
            modified by `calendar.setfirstweekday()`.

        `count` : int
            How many occurrences will be generated by this rule.

        `until` : datetime.datetime
            If given, this must be a `datetime.datetime` instance,
            that will specify the limit of the recurrence. If a
            recurrence instance happens to be the same as the
            `datetime.datetime` instance given in the `until` keyword,
            this will be the last occurrence.

        `bysetpos` : int or sequence
            If given, it must be either an integer, or a sequence of
            integers, positive or negative. Each given integer will
            specify an occurrence number, corresponding to the nth
            occurrence of the rule inside the frequency period. For
            example, a `bysetpos` of `-1` if combined with a `MONTHLY`
            frequency, and a `byday` of `(MO, TU, WE, TH, FR)`, will
            result in the last work day of every month.

        `bymonth` : int or sequence
            If given, it must be either an integer, or a sequence of
            integers, meaning the months to apply the recurrence to.

        `bymonthday` : int or sequence
            If given, it must be either an integer, or a sequence of
            integers, meaning the month days to apply the recurrence
            to.

        `byyearday` : int or sequence
            If given, it must be either an integer, or a sequence of
            integers, meaning the year days to apply the recurrence
            to.

        `byweekno` : int or sequence
            If given, it must be either an integer, or a sequence of
            integers, meaning the week numbers to apply the recurrence
            to. Week numbers have the meaning described in ISO8601,
            that is, the first week of the year is that containing at
            least four days of the new year.

        `byday` : int or sequence
            If given, it must be either an integer `(0 == MO)`, a
            sequence of integers, one of the weekday constants `(MO,
            TU, ...)`, or a sequence of these constants. When given,
            these variables will define the weekdays where the
            recurrence will be applied. It's also possible to use an
            argument n for the weekday instances, which will mean the
            nth occurrence of this weekday in the period. For example,
            with `MONTHLY`, or with `YEARLY` and `BYMONTH`, using
            `FR(1)` in byweekday will specify the first friday of the
            month where the recurrence happens.

        `byhour` : int or sequence
            If given, it must be either an integer, or a sequence of
            integers, meaning the hours to apply the recurrence to.

        `byminute` : int or sequence
            If given, it must be either an integer, or a sequence of
            integers, meaning the minutes to apply the recurrence to.

        `bysecond` : int or sequence
            If given, it must be either an integer, or a sequence of
            integers, meaning the seconds to apply the recurrence to.
    """
    byparams = (
        'bysetpos', 'bymonth', 'bymonthday', 'byyearday',
        'byweekno', 'byday', 'byhour', 'byminute', 'bysecond'
    )
    frequencies = (
        'YEARLY', 'MONTHLY', 'WEEKLY', 'DAILY',
        'HOURLY', 'MINUTELY', 'SECONDLY'
    )
    weekdays = (
        'MO', 'TU', 'WE', 'TH', 'FR', 'SA', 'SU'
    )
    firstweekday = calendar.firstweekday()

    def __init__(
        self, freq,
        interval=1, wkst=None, count=None, until=None, **kwargs):
        """
        Create a new rule.

        See `Rule` class documentation for available `**kwargs` and
        parameter usage.
        """
        self.freq = freq
        self.interval = interval
        self.wkst = wkst
        self.count = count
        self.until = until

        for param in self.byparams:
            if param in kwargs:
                value = kwargs[param]
                if hasattr(value, '__iter__'):
                    value = list(value)
                    if not value:
                        value = None
                elif value is not None:
                    value = [value]
                else:
                    value = None
                setattr(self, param, value)
            else:
                setattr(self, param, None)

    def to_dateutil_rrule(self, dtstart=None, cache=False):
        """
        Create a `dateutil.rrule.rrule` instance from this `Rule`.

        :Parameters:
            `dtstart` : datetime.datetime
                The date/time the recurrence rule starts. This is
                automatically specified by `Recurrence` objects.

            `cache` : bool
                If given, it must be a boolean value specifying to
                enable or disable caching of results. If you will use
                the same `dateutil.rrule.rrule` instance multiple
                times, enabling caching will improve the performance
                considerably.

        :Returns:
            A `dateutil.rrule.rrule` instance.
        """
        kwargs = dict((p, getattr(self, p) or None) for p in self.byparams)
        # dateutil.rrule renames the parameter 'byweekday' by we're using
        # the parameter name originally specified by rfc2445.
        kwargs['byweekday'] = kwargs.pop('byday')
        return dateutil.rrule.rrule(
            self.freq, dtstart,
            self.interval, self.wkst, self.count, self.until,
            cache=cache, **kwargs)


class Recurrence(object):
    """
    A combination of `Rule` and `datetime.datetime` instances.

    A `Recurrence` instance provides the combined behavior of the
    rfc2445 `DTSTART`, `RRULE`, `EXRULE`, `RDATE`, and `EXDATE`
    propeties in generating recurring date/times.

    This is a wrapper around the `dateutil.rrule.rruleset` class while
    adhering to the rfc2445 spec. Notably a `dtstart` parameter can be
    given which cascades to all `dateutil.rrule.rrule` instances
    generated by included `Rule` instances.

    :Variables:
        `dtstart` : datetime.datetime
            Optionally specify the first occurrence. This defaults to
            `datetime.datetime.now()`.

        `rrules` : list
            A list of `Rule` instances to include in the recurrence
            set generation.

        `exrules` : list
            A list of `Rule` instances to include in the recurrence
            set exclusion list. Dates which are part of the given
            recurrence rules will not be generated, even if some
            inclusive `Rule` or `datetime.datetime` instances matches
            them.

        `rdates` : list
            A list of `datetime.datetime` instances to include in the
            recurrence set generation.

        `exdates` : list
            A list of `datetime.datetime` instances to exclude in the
            recurrence set generation. Dates included that way will
            not be generated, even if some inclusive `Rule` or
            `datetime.datetime` instances matches them.
    """
    def __init__(
        self, dtstart=None,
        rrules=[], exrules=[], rdates=[], exdates=[]):
        """
        Create a new recurrence.

        Parameters map directly to instance attributes, see
        `Recurrence` class documentation for usage.
        """
        self._cache = {}

        self.dtstart = dtstart
        self.rrules = list(rrules)
        self.exrules = list(exrules)
        self.rdates = list(rdates)
        self.exdates = list(exdates)

    def __iter__(self):
        return self.__call__()

    def __unicode__(self):
        return serialize(self)

    def __call__(self, dtstart=None, tzinfo=None, cache=False):
        """
        Get a generator yielding `datetime.datetime` instances in this
        recurrence set.

        :Parameters:
            `dtstart` : datetime.datetime
                Optionally specify the first occurrence of the
                recurrence set. Defauts to `datetime.datetime.now()`.

            `tzinfo` : datetime.tzinfo
                Optionally specify the timezone to adjust the
                recurrence set to.

            `cache` : bool
                Whether to cache the recurrence set generator.

        :Returns:
            A sequence of `datetime.datetime` instances.
        """
        return iter(self._recurrence_generator(
            self.to_dateutil_rruleset(dtstart, cache), tzinfo))

    def _recurrence_generator(self, sequence, tzinfo):
        # adjust timezone info for each datetime object in the
        # sequence
        for dt in sequence:
            if not dt.tzinfo:
                dt = localtz.localize(dt)
            yield dt.astimezone(tzinfo or localtz)

    def before(self, dt, inc=False, dtstart=None, tzinfo=None, cache=False):
        """
        Returns the last recurrence before the given
        `datetime.datetime` instance.

        :Parameters:
            `dt` : datetime.datetime
                The date to use as the threshold.

            `inc` : bool
                Defines what happens if `dt` is an occurrence. With
                `inc == True`, if `dt` itself is an occurrence, it
                will be returned.

            `dtstart` : datetime.datetime
                Optionally specify the first occurrence of the
                recurrence set. Defauts to `datetime.datetime.now()`.

            `tzinfo` : datetime.tzinfo
                Optionally specify the timezone to adjust the
                recurrence set to.

            `cache` : bool
                Whether to cache the recurrence set generator.

        :Returns:
            A `datetime.datetime` instance.
        """
        if not dt.tzinfo:
            dt = localtz.localize(dt)
        before_dt = self.to_dateutil_rruleset(dtstart, cache).before(dt, inc)
        if not before_dt:
            return None
        return list(self._recurrence_generator([before_dt], tzinfo))[0]

    def after(self, dt, inc=False, dtstart=None, tzinfo=None, cache=False):
        """
        Returns the first recurrence after the given
        `datetime.datetime` instance.

        :Parameters:
            `dt` : datetime.datetime
                The date to use as the threshold.

            `inc` : bool
                Defines what happens if `dt` is an occurrence. With
                `inc == True`, if `dt` itself is an occurrence, it
                will be returned.

            `dtstart` : datetime.datetime
                Optionally specify the first occurrence of the
                recurrence set. Defauts to `datetime.datetime.now()`.

            `tzinfo` : datetime.tzinfo
                Optionally specify the timezone to adjust the
                recurrence set to.

            `cache` : bool
                Whether to cache the recurrence set generator.

        :Returns:
            A `datetime.datetime` instance.
        """
        if not dt.tzinfo:
            dt = localtz.localize(dt)
        after_dt = self.to_dateutil_rruleset(dtstart, cache).after(dt, inc)
        if not after_dt:
            return None
        return list(self._recurrence_generator([after_dt], tzinfo))[0]

    def between(
        self, after, before,
        inc=False, dtstart=None, tzinfo=None, cache=False):
        """
        Returns the first recurrence after the given
        `datetime.datetime` instance.

        :Parameters:
            `after` : datetime.datetime
                Return dates after this date.

            `before` : datetime.datetime
                Return dates before this date.

            `inc` : bool
                Defines what happens if `after` and/or `before` are
                themselves occurrences. With `inc == True`, they will
                be included in the list, if they are found in the
                recurrence set.

            `dtstart` : datetime.datetime
                Optionally specify the first occurrence of the
                recurrence set. Defauts to `datetime.datetime.now()`.

            `tzinfo` : datetime.tzinfo
                Optionally specify the timezone to adjust the
                recurrence set to.

            `cache` : bool
                Whether to cache the recurrence set generator.

        :Returns:
            A sequence of `datetime.datetime` instances.
        """
        if not after.tzinfo:
            after = localtz.localize(after)
        if not before.tzinfo:
            before = localtz.localize(before)
        return list(self._recurrence_generator(
            self.to_dateutil_rruleset(dtstart, cache).between(
            after, before, inc), tzinfo))

    def to_dateutil_rruleset(self, dtstart=None, cache=False):
        """
        Create a `dateutil.rrule.rruleset` instance from this
        `Recurrence`.

        :Parameters:
            `dtstart` : datetime.datetime
                The date/time the recurrence rule starts. This value
                overrides the `dtstart` property specified by the
                `Recurrence` instance if its set.

            `cache` : bool
                If given, it must be a boolean value specifying to
                enable or disable caching of results. If you will use
                the same `dateutil.rrule.rrule` instance multiple
                times, enabling caching will improve the performance
                considerably.

        :Returns:
            A `dateutil.rrule.rruleset` instance.
        """
        dtstart = dtstart or self.dtstart
        if dtstart:
            if not dtstart.tzinfo:
                dtstart = localtz.localize(dtstart)

        if cache:
            # we need to cache an instance for each unique dtstart
            # value because the occurrence values will differ.
            cached = self._cache.get(dtstart)
            if cached:
                return cached

        rruleset = dateutil.rrule.rruleset(cache=cache)
        for rrule in self.rrules:
            rruleset.rrule(rrule.to_dateutil_rrule(dtstart, cache))
        for exrule in self.exrules:
            rruleset.exrule(exrule.to_dateutil_rrule(dtstart, cache))
        if dtstart is not None:
            rruleset.rdate(dtstart)
        for rdate in self.rdates:
            rruleset.rdate(rdate)
        for exdate in self.exdates:
            rruleset.exdate(exdate)

        if cache:
            self._cache[dtstart] = rruleset

        return rruleset


def to_weekday(token):
    """
    Attempt to convert an object to a `dateutil.rrule.weekday`
    constant.

    :Parameters:
        `token` : str, int, or dateutil.rrule.weekday
            Can be values such as `MO`, `SU(-2)`, `"-2SU"`, or an
            integer like `1` for Tuesday. dateutil.rrule.weekday`
            are returned unchanged.

    :Returns:
        A `dateutil.rrule.weekday` instance.
    """
    if issubclass(token.__class__, dateutil.rrule.weekday):
        return token
    if isinstance(token, int):
        if token > 6:
            raise ValueError
        return dateutil.rrule.weekdays[token]
    elif not token:
        raise ValueError
    elif isinstance(token, basestring) and token.isdigit():
        if int(token) > 6:
            raise ValueError
        return dateutil.rrule.weekdays[int(token)]
    elif isinstance(token, basestring):
        const = token[-2:].lower()
        if const not in Rule.weekdays:
            raise ValueError
        nth = token[:-2]
        if not nth:
            return dateutil.rrule.weekday(
                Rule.weekdays.index(const))
        else:
            return dateutil.rrule.weekday(
                Rule.weekdays.index(const), int(nth))


def serialize(rule_or_recurrence):
    """
    Serialize a `Rule` or `Recurrence` instance.

    `Rule` instances are wrapped as an rrule in a `Recurrence`
    instance before serialization, and will serialize as the `RRULE`
    property.

    :Returns:
        A rfc2445 formatted unicode string.
    """
    def serialize_dt(dt):
        if not dt.tzinfo:
            dt = localtz.localize(dt)
        dt = dt.astimezone(pytz.utc)

        return u'%s%s%sT%s%s%sZ' % (
            str(dt.year).rjust(4, '0'),
            str(dt.month).rjust(2, '0'),
            str(dt.day).rjust(2, '0'),
            str(dt.hour).rjust(2, '0'),
            str(dt.minute).rjust(2, '0'),
            str(dt.second).rjust(2, '0'),
        )

    def serialize_rule(rule):
        values = []
        values.append((u'FREQ', [Rule.frequencies[rule.freq]]))

        if rule.interval != 1:
            values.append((u'INTERVAL', [str(rule.interval)]))
        if rule.wkst:
            values.append((u'WKST', [Rule.weekdays[rule.wkst]]))
        if rule.count is not None:
            values.append((u'COUNT', [str(rule.count)]))
        elif rule.until is not None:
            values.append((u'UNTIL', [serialize_dt(rule.until)]))

        if rule.byday:
            days = []
            for d in rule.byday:
                d = to_weekday(d)
                if d.n:
                    days.append(u'%s%s' % (d.n, Rule.weekdays[d.weekday]))
                else:
                    days.append(Rule.weekdays[d.weekday])
            values.append((u'BYDAY', days))

        remaining_params = list(Rule.byparams)
        remaining_params.remove('byday')
        for param in remaining_params:
            value_list = getattr(rule, param, None)
            if value_list:
                values.append((param.upper(), [str(n) for n in value_list]))

        return u';'.join(u'%s=%s' % (i[0], u','.join(i[1])) for i in values)

    obj = rule_or_recurrence
    if isinstance(obj, Rule):
        obj = Recurrence(rrules=[obj])

    items = []
    if obj.dtstart:
        if obj.dtstart.tzinfo:
            dtstart = serialize_dt(obj.dtstart.astimezone(pytz.utc))
        else:
            dtstart = serialize_dt(
                localtz.localize(obj.dtstart).astimezone(pytz.utc))
        items.append((u'DTSTART', dtstart))
    for rrule in obj.rrules:
        items.append((u'RRULE', serialize_rule(rrule)))
    for exrule in obj.exrules:
        items.append((u'EXRULES', serialize_rule(exrule)))
    for rdate in obj.rdates:
        if rdate.tzinfo:
            rdate = serialize_dt(rdate.astimezone(pytz.utc))
        else:
            rdate = serialize_dt(
                localtz.localize(rdate).astimezone(pytz.utc))
        items.append((u'RDATE', serialize_dt(rdate)))
    for exdate in obj.exdates:
        if exdate.tzinfo:
            exdate = serialize_dt(exdate.astimezone(pytz.utc))
        else:
            exdate = serialize_dt(
                localtz.localize(exdate).astimezone(pytz.utc))
        items.append((u'EXDATE', serialize_dt(exdate)))

    return u'\n'.join(u'%s:%s' % i for i in items)


def deserialize(text):
    """
    Deserialize a rfc2445 formatted string.

    :Returns:
        A `Recurrence` instance.
    """
    def deserialize_dt(text):
        year, month, day = int(text[:4]), int(text[4:6]), int(text[6:8])
        if u'T' in text:
            hour, minute, second = (
                int(text[9:11]), int(text[11:13]), int(text[13:15]))
        else:
            hour, minute, second = (0, 0, 0)
        if u'Z' in text:
            tzinfo = pytz.utc
        else:
            # right now there is no support for VTIMEZONE/TZID since
            # this is a partial implementation of rfc2445 so we'll
            # just use the time zone specified in the Django settings.
            tzinfo = localtz
        return datetime.datetime(
            year, month, day, hour, minute, second, tzinfo=tzinfo)

    dtstart, rrules, exrules, rdates, exdates = None, [], [], [], []

    tokens = re.compile(
        u'(DTSTART|RRULE|EXRULE|RDATE|EXDATE)[^:]*:(.*)',
        re.MULTILINE).findall(text)

    for label, param_text in tokens:
        if u'=' not in param_text:
            params = param_text
        else:
            params = {}
            param_tokens = param_text.split(u';')
            for item in param_tokens:
                param_name, param_value = map(
                    lambda i: i.strip(), item.split(u'=', 1))
                params[param_name] = map(
                    lambda i: i.strip(), param_value.split(u','))

        if label in (u'RRULE', u'EXRULE'):
            kwargs = {}
            for key, value in params.items():
                if key == u'FREQ':
                    kwargs[str(key.lower())] = list(
                        Rule.frequencies).index(value[0])
                elif key == u'INTERVAL':
                    kwargs[str(key.lower())] = int(value[0])
                elif key == u'WKST':
                    kwargs[str(key.lower())] = to_weekday(value[0])
                elif key == u'COUNT':
                    kwargs[str(key.lower())] = int(value[0])
                elif key == u'UNTIL':
                    kwargs[str(key.lower())] = deserialize_dt(value[0])
                elif key == u'BYDAY':
                    kwargs[str(key.lower())] = map(lambda v: to_weekday(v), value)
                else:
                    kwargs[str(key.lower())] = map(lambda v: int(v))
            if label == u'RRULE':
                rrules.append(Rule(**kwargs))
            else:
                exrule.append(Rule(**kwargs))
        elif label == u'DTSTART':
            dtstart = deserialize_dt(params)
        elif label == u'RDATE':
            rdates.append(deserialize_dt(params))
        elif label == u'EXDATE':
            exdates.append(deserialize_dt(params))

    return Recurrence(dtstart, rrules, exrules, rdates, exdates)


def from_dateutil_rrule(rrule):
    """
    Convert a `dateutil.rrule.rrule` instance to a `Rule` instance.

    :Returns:
        A `Rrule` instance.
    """
    kwargs = {}
    kwargs['freq'] = rrule._freq
    kwargs['interval'] = rrule._interval
    if rrule._wkst != 0:
        kwargs['wkst'] = rrule._wkst
    kwargs['bysetpos'] = rrule._bysetpos
    if rrule._count is not None:
        kwargs['count'] = rrule._count
    elif rrule._until is not None:
        kwargs['until'] = rrule._until

    days = []
    if (rrule._byweekday is not None and (
        WEEKLY != rrule._freq or len(rrule._byweekday) != 1 or
        rrule._dtstart.weekday() != rrule._byweekday[0])):
        # ignore byweekday if freq is WEEKLY and day correlates
        # with dtstart because it was automatically set by
        # dateutil
        days.extend(dateutil.rrule.weekday(n) for n in rrule._byweekday)

    if rrule._bynweekday is not None:
        days.extend(dateutil.rrule.weekday(*n) for n in rrule._bynweekday)

    if len(days) > 0:
        kwargs['byday'] = days

    if rrule._bymonthday is not None and len(rrule._bymonthday) > 0:
        if not (rrule._freq <= MONTHLY and len(rrule._bymonthday) == 1 and
            rrule._bymonthday[0] == rrule._dtstart.day):
            # ignore bymonthday if it's generated by dateutil
            kwargs['bymonthday'] = list(rrule._bymonthday)

    if rrule._bynmonthday is not None and len(rrule._bynmonthday) > 0:
        kwargs.setdefault('bymonthday', []).extend(rrule._bynmonthday)

    if rrule._bymonth is not None and len(rrule._bymonth) > 0:
        if (rrule._byweekday is not None or
            len(rrule._bynweekday or ()) > 0 or not (
            rrule._freq == YEARLY and len(rrule._bymonth) == 1 and
            rrule._bymonth[0] == rrule._dtstart.month)):
            # ignore bymonth if it's generated by dateutil
            kwargs['bymonth'] = list(rrule._bymonth)

    if rrule._byyearday is not None:
        kwargs['byyearday'] = list(rrule._byyearday)
    if rrule._byweekno is not None:
        kwargs['byweekno'] = list(rrule._byweekno)

    kwargs['byhour'] = list(rrule._byhour)
    kwargs['byminute'] = list(rrule._byminute)
    kwargs['bysecond'] = list(rrule._bysecond)
    if (rrule._dtstart.hour in rrule._byhour and
        rrule._dtstart.minute in rrule._byminute and
        rrule._dtstart.second in rrule._bysecond):
        # ignore byhour/byminute/bysecond automatically set by
        # dateutil from dtstart
        kwargs['byhour'].remove(rrule._dtstart.hour)
        kwargs['byminute'].remove(rrule._dtstart.minute)
        kwargs['bysecond'].remove(rrule._dtstart.second)

    return Rule(**kwargs)


def from_dateutil_rruleset(rruleset):
    """
    Convert a `dateutil.rrule.rruleset` instance to a `Recurrence`
    instance.

    :Returns:
        A `Recurrence` instance.
    """
    rrules = [from_dateutil_rrule(rrule) for rrule in rruleset._rrule]
    exrules = [from_dateutil_rrule(exrule) for exrule in rruleset._exrule]
    rdates = rruleset._rdate
    exdates = rruleset._exdate

    dts = [r._dtstart for r in rruleset._rrule] + rruleset._rdate
    if len(dts) > 0:
        dts.sort()
        dtstart = dts[0]
    else:
        dtstart = None

    return Recurrence(dtstart, rrules, exrules, rdates, exdates)
